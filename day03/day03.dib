#!fsharp

// Day 03 Pt 1

let input = File.ReadAllLines(@"input.txt") |> Array.toList

let analyze_compartments input =
    let rec get_priorities input priorities =
        match input with
        |line :: tail ->
            let compartment_size = line |> String.length 
            let compartment_one = line[0 .. compartment_size/2 - 1] |> Seq.toList |> Set.ofList // create a set from each compartment
            let compartment_two = line[compartment_size/2 ..] |> Seq.toList |> Set.ofList
            let duplicate = Set.intersect compartment_one compartment_two // intersection of 2 sets is common items
            let priority =  // convert char to priority value
                match Char.IsUpper(Set.maxElement duplicate) with
                | true -> Set.fold (fun acc element -> acc + int element - 38) 0 duplicate
                | false -> Set.fold (fun acc element -> acc + int element - 96) 0 duplicate
            get_priorities tail (priority + priorities) 
        |[] -> priorities
    get_priorities input 0

let priorities = analyze_compartments input
printfn "%A" priorities

#!fsharp

// Day 03 Pt 2
// need to accumulate over 3 lines, so make accumulator a list and match its length
// will need 2 accumulators: the buffer for the 3 lines and the total accumulation
let input = File.ReadAllLines(@"input.txt") |> Array.toList

let get_badge_score (input : list<string>) =

    let match_priority c = 
        match Char.IsUpper(c) with
        | true -> int c - 38
        | false -> int c - 96

    let rec get_priorities (input : list<string>) (buffer : list<Set<char>>) (priorities: int) =
        match input with
        |line :: tail ->
            match List.length buffer with
            | 3 -> // when the buffer is full
                let line_seq = line |> Set.ofSeq
                let badge = buffer |> Seq.ofList |> Set.intersectMany |> Set.maxElement
                let priority =  match_priority badge // get priority value for char
                get_priorities tail [line_seq] (priorities + priority)
            | _ -> 
                let line_seq = line |> Set.ofSeq
                get_priorities tail (buffer @ [line_seq]) priorities
        |[] -> // assuming empty list will have a full buffer
            let badge = buffer |> Seq.ofList |> Set.intersectMany |> Set.maxElement
            let priority = match_priority badge
            priorities + priority // return the final badge priority score
    get_priorities input [] 0 // initialize recursive function with empty accumulators

let badgeScore = get_badge_score input
printfn "%A" badgeScore
